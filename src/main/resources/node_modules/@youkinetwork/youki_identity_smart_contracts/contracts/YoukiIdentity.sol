// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <0.9.0;

import "./libraries/AddressLib.sol";
import "./libraries/BirthDataLib.sol";
import "./libraries/IdentityLib.sol";
import "./helpers/DataValidation.sol";
import "./helpers/ElementResearch.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

import "./DTO/IdentityDTO.sol";

contract YoukiIdentity is Ownable, DataValidation, ElementResearch {

    Identity public identity;
    bytes32 public emailHash; // stores the email as a keccak256 hash
    mapping(Role => address) rolesContracts; // mapping to the user roles contracts
    uint[] roles;

    event newRoleAdded(Role _role, address _roleContract);

    modifier onlyIfRoleDoNotexists(uint256 _role) {
        if (uintExists(_role,roles ) == true) {
            revert("role already exists");
        }
        _;
    }

    modifier onlyIfItHaveRole(uint256[] memory _roles) {
        if (_roles.length == 0) {
            revert("a role must be specified");
        }
        _;
    }


    /**
     * Constructor of the Identity
     */
    constructor(IdentityDTO memory _identity)
        throwIfAddressIsInvalid(_identity.walletAddress)
        throwIfIsEmptyString(_identity.lastname)
        throwIfIsEmptyString(_identity.salutation)
        throwIfIsEmptyString(_identity.email)
    {
        // Initiliaze the identity structure
        identity.personalData = IdentityPersonalData({
            salutation: _identity.salutation,
            firstname: _identity.firstname,
            lastname: _identity.lastname,
            personType: _identity.personType,
            walletAddress: _identity.walletAddress
        });

        identity.contactData = IdentityContactData({
            email: _identity.email,
            emailVerified: false,
            mobileNumber: _identity.mobileNumber
        });

        identity.metaInformation = EntityMetaInformation({
            creationDateTime: block.timestamp,
            modificationDateTime: block.timestamp
        });

        // save hashed user email
        emailHash = keccak256(abi.encodePacked(_identity.email));
        //transfert ownership from the identity handler to the wallet of user
        transferOwnership(_identity.walletAddress);
    }

    function setIdentityAdditionalData(
        Maritalstatus _Maritalstatus,
        string memory _education,
        string memory _nationality,
        string[] memory _furtherNationalities,
        string memory _dateOfBirth,
        string memory _placeOfBirth,
        string memory _countryOfBirth,
        string memory _title,
        string memory _profession
    ) public onlyOwner throwIfIsEmptyString(_nationality) returns (uint256) {
        identity.additionalData = IdentityAdditionalData({
            maritalstatus: _Maritalstatus,
            nationality: _nationality,
            education: _education,
            furtherNationalities: _furtherNationalities,
            birthdata: BirthData({
                dateOfBirth: _dateOfBirth,
                placeOfBirth: _placeOfBirth,
                countryOfBirth: _countryOfBirth
            }),
            title: _title,
            profession: _profession
        });

        identity.metaInformation.modificationDateTime = block.timestamp;
        return (identity.metaInformation.modificationDateTime);
    }

    function setIdentityAddress(
        string memory _streetHouseNumber, // !=0
        string memory _zip, // !=0
        string memory _city, // !=0
        string memory _country // !=0
    )
        public
        onlyOwner
        throwIfIsEmptyString(_streetHouseNumber)
        throwIfIsEmptyString(_zip)
        throwIfIsEmptyString(_city)
        throwIfIsEmptyString(_country)
    {
        identity.userAddress = Address({
            streetHouseNumber: _streetHouseNumber,
            zip: _zip,
            city: _city,
            country: _country
        });

        identity.metaInformation.modificationDateTime = block.timestamp;
    }


    /**
     * @dev get identity details
     * @return a tupple of the identity info
     */
    function getIdentity() public view returns (Identity memory) {
        return identity;
    }

    /**
     * @dev get identity email hash
     * @return a bytes32 of the identity emailHash
     */
    function getEmailHash() public view returns (bytes32) {
        return emailHash;
    }

    function addNewRole(uint256 _role, address _roleContract )
        external 
        onlyIfRoleDoNotexists(_role)
        {
        roles.push(_role);
        rolesContracts[Role(_role)] = _roleContract;
    }
}
